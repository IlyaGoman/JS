1. Information

    Спецификация
            https://www.ecma-international.org/publications-and-standards/standards/ecma-262/
    
    Справочники
            MDN (Mozilla) JavaScript Reference
                https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference
            
            MSDN
                https://docs.microsoft.com/ru-ru/

2. Browser enviroment

    window (Global object)
        - DOM (Document Object Model) - объектая модель документа, пердоставляет доступ к содержимому страницы в виде объектов.
            DOM Living Standart
                https://dom.spec.whatwg.org/
        - BOM (Browser Object Model) - доп.объекты, чтобы работать со всем, кроме document
            Спецификация HTML
                https://html.spec.whatwg.org/

        https://spec.whatwg.org/

3. Основы JavaScript
            use strict - используется в начале скрипта для работы в "современном" режиме
                'use strict' или "use strict"

            let(уст. var) - объявление переменной. Регистрозависимы. Буквы, цифры, $ и _, не с цифры. CamelCase.
                let message = 'Hello JS';
                alert(message);

                В нестрогом режиме можно объявлять без let(var).
        
            const - объявление константы.
                Если объявляется до выполнения скрипта, то можно заглавными.

        Типы данных
            - number - числовой тип(целые, дробные). -pow(2, 53) ~ pow(2, 53)
                - Infinity - математическая бесконечность(можно получить в результате деления на ноль alert(1 / 0); //Infinity)
                - NaN - вычислительная ошибка (alert("строка" / 5); //NaN)
            - bigint - числа произвольной длины (добавляем в конце 'n'). Поддерживается только в браузерах Firefox, Chrome, Edge и Safari.
                let num = 123123123123123123123123n;
            - string - строчный. Выделяется двойными или одинарными кавычками.
                let firstName = 'Ilya';
                let secondName = "Goman";

                Обратные кавычки позволяют встраивать выражения в строку
                    let fullName = `${firstName} ${secondName}`;
            
            - boolean - true/false

            - null - представляет собой «ничего», «пусто» или «значение неизвестно». Используется для присвоения пустого значения.
            - undefined - значение не определено. Используется для проверки, была ли переменная назначена.
                let name;
                alert(name); //undefined
            - object - может содержать простые значения. будь то строка, число, или что-то еще.
            - symbol - используется для создания уникальных идентификаторов в объектах.

            Оператор typeof возвращает тип аргумента.
                typeof 0 // number
                typeof 10n // bigint
                typeof 'dfsakda' // string

        Alert, Prompt, Confirm

            alert - вывод информации в виде модального окна с "ОК"
                alert("text");

            promt(text, [default]) - модальное окно с "ОК/Отмена". Возвращает текст, введенный пользователем.
                text - текстовое сообщение
                [default] - необязательны параметр, который подставляется в значение.
                    result = prompt("Сколько тебе лет?");
                    result = prompt("Сколько тебе лет?", 111);
                    В случае отмены возвращает null, кроме IE - он вставит undefined. Рекомендуется вставлять значение по умолчанию для корректной работы в IE.
            
            confirm - модальное окно с вопросом и кнопками "ОК/Отмена". Возвращает true/false.

        Преобразование типов

            String(value) - преобразование в строку.

            Number(value) - преобразование к числу. Если строка не может быть приведена к числу, то получим NaN(преобразование не удалось).
                undefined -> NaN
                null -> 0
                true / false -> 1 / 0
                string -> Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

            Boolean(value)
                - Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false
                - Все остальное - true.


        Циклы

            while(i < 3)
            {
                alert(i);
                i++;
            }

            do
            {
                alert(i);
                i++;
            } while(condition)

            for(let i = 0; i < 3; i++)
            {
                alert(i);
            }

            Метка для break/continue до определенного уровня вложенности.
            labelName: 
            for(let i = 0; i < 3; i++)
            {
                for(let j = 0; j < 3; j++)
                {
                    if(i % 2 === 0)
                        {
                            break labelName;
                        }    
                    alert(i);
                }
            }

        Проверка на равенство в switch() всегда строгая, поэтому кроме значения должен совпадать и тип.
        SWITCH(x)
        {
            case value1:
                alert(x);
                break;

            case value2:
                alert(x);
                break;

            case value3:
                alert(x);
                break;
            
            default:
                alert(x);
        }

        Функции

            function nameFunc(params){
                body;
            }

            Function Expression

                let sayHi = function(){
                    alert("Hi");
                }

                sayHi();

            Функции-"коллбэки"
                передача функции как значения
                function ask(question, yes, no){
                    (confirm(question)) ? yes() : no();
                 } 
                 Здесь yes и no функции yes() и no().

            Стрелочные функции
                let func = (arg1, arg2, ...argN) => expression;

                let sum = (a, b) => a + b;
                alert( sum(1, 2) ); // 3

        Тестирование (mocha)
            Тестирование через поведение(TDD)
                describe("nameFunction", function(){

                    it("Описание процесса и результата", function(){
                        assert.equal("nameFunction"(params), result)
                        //isNaN, isTrue etc...
                    });
                };)


4. Объекты: Основы

    Объекты - ключом может быть только строка!
        let user = new object();
        или
        let user = {};

        let user = {
            name: "Ilya",
            age: 36
        }
        alert(user.name);

        Добавление св-ва объекта
            user.fullName = "Ilya Goman";
        Удаление св-ва
            delete user.fullName;

        Имена св-в через переменные
            function makeUser(name, age){
                return {
                    name: name,
                    age: age
                };
            }

        Проверка существования св-ва в объекте через in
            let user = {name: "Ilya", age: 30};
            alert("name" in user); //return true
            alert("isAdmin" in user); //return false

        Цикл for (key in objectName) перебирает все св-ва объекта
            for (key in user){
                alert(key);
            }

        Обеъкты ссылочные типа.
            let a = {name: "Ilya"};
            let b = a; a и b один и тот же объект!
            b.name = "John";
            alert(a.name); //John

        Для клонирования обектов:
            1) let a = {name: "Ilya"};
               let b = {};
               for (let key in a){
                   b[key] = a[key];
               }
            2) Object.assign(dest, src1, src2....srcN) - клонируем в объект dest объекты src1, src2...srcN.
               Одинаковые сво-ва перезаписываются!
               let a = {name: "Ilya"};
               let b = Object.assign({}, a); // a и b независимые объекты.
               Не забывать, что свойством объекта может быть другой объект, тогда примитивное копирование не пройдет!
               В этом случае необходима проверка, что свойство является объектом.

    Методы объектов, this
        Значение this – это объект «перед точкой», который использовался для вызова метода.
            let user = {
                name: "Ilya",
                age: 36,
                sayHi() {
                    alert( "Hi " + this.name );
                    }
            };

            user.sayHi();

        Значение this вычисляется во время выполнения кода и зависит от контекста.
            В "use strict" вызов alert(this) вернет undefined, в нестрогом - window.

            значение this передаётся правильно, только если функция 
                вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']().

            Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
    
    Функции конструкторы
        function User(name){
            this.name = name;
            this.isAdmin = false;
        }

        let user = new User("Ilya");

        Если параметры функции отсутствуют, то можно опустить ()

    Тип Symbol

        let id = Symbol("id");
        Symbol не конвертируется автоматом к String, для этого используется метод .toString()
            alert(id.toString()); //Symbol(id)

        Symbol можно использовать как скрытое св-во объекта, т.к. для циклов перебора поля этого типа он не видны.
            let id = Symbol("id");
            let user= {
                name: "Ilya",
                age: 36,
                [id]: 123
            };

        Глобальные символы
            let id = Symbol.for("id"); // считывает из глобального реестра, а если его там нет, то создает.
            Symbol.for(key) - Для чтения/создания из глобального реестра. // 
            Symbol.keyFor(key) - принимает глобальный символ и возвращает его имя.

        Числа
            let billion = 1000000000; => let billion = 1e9;
            let ms = 0.000001 => let ms = 1e-6;

            alert( 0xff ); // 255

            num.toString(base) - возвращает строковое представление числа в системе base
            alert(255..toString()); //"255"
            alert(255..toString(16)); //"ff"
            alert(255..toString(2)); //"11111111"
            В данном случае .. используются при обращении напрямую к числу, чтобы не ошибиться с дробными.
            Для вызова на переменных достаточно однйо точки.

            Округление через Math.floor - вниз, Math.ceil - вверх, Math.round - ближайшее(не поддерживается в IE)

            num.to Fixed(n) - оставляет n знаков после запятой. Возвращает СТРОКУ.

            isNan(value) - преобразует значение в число и проверяет является ли оно NaN
                alert( isNaN(NaN) ); // true
                alert( isNaN("str") ); // true
            isFinite(value) - преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
                alert( isFinite("15") ); // true
                alert( isFinite("str") ); // false, потому что специальное значение: NaN
                alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
                Можно использовать для проверки является ли строка числом:
                isFinite(+prompt("Input number", ""));

            parseInt/parseFloat - Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число.
                Вернут NaN, если не смогли прочитать ни одну цифру.
                alert( parseInt("100px")); //100
                alert( parseInt("px100")); //NaN
        
        Строки
            Неизменяемы(Immutable)
            ""
            ''
            ``
            `${let}` - вставка переменной в строку(форматирование)
            \ - экранирование
            str.lenght - длина строки
            str.charAt[n] - возврат символа из строки с позиции n.
                    Несуществующий индекс вернет пустую строку.
            str[0] - аналог
                    Несуществующий индекс вернет undefined.

            Строку можно перебрать посимвольно циклом
                for .. of ..
                    for ( let char of "Hello"){
                        alert(char);
                    }

            str.toUpperCase() - к верхнему регистру
            str.toLowerCase() - к нижнему регистру
                str[3].toLowerCase() - перевод конкретного символа
            str.indexOf(sub, pos) - поиск подстроки. Возвращает позицию или -1
                - sub  - искомая строка
                - pos - начиная с какой позиции, по умолчанию 0
            str.includes(sub, pos) - проверяет на наличие подстроки
            
            Проверка на начало/окончание с подстроки
                str.startsWith(sub)
                str.endWith(sub)

            str.slice(start, [,end]) - возвращает подстроку начиная со start и до end(не включительно). Если end нет, то до конца строки.
                Отрицательные аргументы - с конца строки.

            str.substring(start, [,end]) - возвращает подстроку начиная со start и до end(не включительно).
                Отрицательные аргументы интерпретируются как 0.
                Если start<end, то они меняются местами.
                    "HELLO".substring(1,3); //EL
                    "HELLO".substring(3,1); //EL

            str.substr(start, lenght) - возвращает подстроку длиной lenght начиная со start.
                Если start<0, то начиная с конца строки.

            str.codePointAt(pos) - код символа в UTF-16
            str.fromCodePOint(code) - создает символ по его коду.

            str.trim() - пробелы в начале и конце строки
            str.repeat(n) - Повторяет строк n раз.

        Методы массивов
            arr.splice(index[, deleteCount, elem1, ..., elemN]) - удаление из массива
                - index - с какого элемента начать
                - deleteCount - сколько элементов удалить
                - elem1...elemN - на какие элементы заменить

                    ["I", "learn", "JS"].splice(1,1); //["I", "JS"]
                    ["I", "learn", "JS"].splice(0,2, "ILYA", "GOMAN"); //["ILYA", "GOMAN", "JS"]
            
            arr.slice(start, end) - возвращает часть массива от start до end
                arr.slice() - создаст копию массива
            
            arr.concat(arg1, arg2...) - создает новый массив, в который копирует все.
                arr.concat([1,2,3], "ILYA", 1); //[1,2,3,"ILYA, 1]

            arr.forEach(function(ite, index, array){
                // ...что-то делам с item
            });
                arr.forEach(alert); вывод всех элементов массива

            arr.indexOf(item, from) - ищем item с индекса from. Возвращает индекс или -1
            arr.lastIndexOf(item, from) - ищет справа. Возвращает индекс или -1
            arr.includes(item, from) - возвращает true, если найден

            arr.find(function(item, index, array)) -  возвращает текущий элемент, иначе undefined
                let user =[
                    {id: 1, name: "ILYA"},
                    {id: 2, name: "IVAN"},
                    {id: 3, name: "YOULA"},
                }
                user = arr.find(item => item.id==1); 
                alert (user.name ); //"ILYA"
            arr.findIndex() - аналогично arr.find(), но возвращает индекс или -1

            arr.filter(function(item, index, array)) - возвращает массив из всех подходящих

            



        Итерируемые объекты

            Объекты содержащие метод с именем Symbol.iterator, чтобы можно было перебирать циклом for .. of ..
            Этот метод возвращает итератор next(), который и выполняет перебор.
            Результат next() должен быть вида {done: Boolean, value: any}

            let range = {
                from: 1,
                to: 5
            };
            
            //Добавим метод для итерации
            range[Symbol.iterator] = function(){
                return {
                    current: this.from,
                    last: this.to,
                    next(){
                        if(this.current <= this.last)
                            return {done: false, value: this.current++};
                        else {
                            return {done: true};
                        }
                    }
                };
            };

        Map и Set

            Map - хранит коллекцию ключ/значение, позволяет использовать ключи любого типа.
                new Map() - создает коллекцию
                map.set(key, value) - устанавливает значение
                map.get(key) - получает значение по ключу
                map.has(key) - true, если ключ существует
                map.delete(key) - удалает по ключу
                map.clear() - очищает всю коллекцию
                map.size - возвращает размер коллекции

                let map = new Map();

                map.set("1", "str1");
                map.set(1, "str2");
                map.set(true, "bool1");

                alert( map.get(1) ); //"str2"
                alert( map.get(true) ); //"bool1"
                alert( map.size ); //3

                В качестве ключей можно использователь объекты!

                Т.к. .set возвращает каждый раз map, то:
                    
                    map.set("1", "str1");
                    map.set(1, "str2");
                    map.set(true, "bool1");
                можно заменить на:
                    map.set("1", "str1");
                       .set(1, "str2");
                       .set(true, "bool1");

                Перебор в Map(for .. of ..)
                    map.keys() - перебор всех ключей
                    map.values() - перебор всех значений
                    map.entries() - возвращает итерируемый объект вида [key, value]

                    map.forEach((value, key, map) => {alert(`${key} : ${value}`)};)

                Object.entries(obj) - преобразует любой объект к Map
                Object.fromEntries(map) - преобразует Map в объект

            Set - коллекция без ключей, где каждое значение может быть только один раз.
                set.add(value);
                set.delete(value);
                set has(value);
                set.clear();
                set.size

                Для перебора либо for/of, либо forEach()
                    set.forEach((value, valueAgain, set) => {alert(value)};) //valueAgain существует для совместимости с Map
                    set.keys() - перебор всех ключей
                    set.values() - перебор всех значений
                    set.entries() - возвращает итерируемый объект вида [value, value]

            WeakMap - аналог Map, ключом может быть только Объект.
                        Соответственно, если объект удаляется, то и данные из WeakMap удаляются.
            WeakSet - аналог Set, но содержит в себе только объекты.

            WeakMap, WeakSet - нельзя перебирать!


    Деструктирующее присваивание
        Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны.

            Массивы
                let arr = ["Ilya", "Ivan"];
                let [firstName, secondName] = arr;
                alert(firstName); //"Ilya"
                alert(secondName); //"Ivan"

                let [firstName, secondName] = "Ilya Ivan".split(" ");

                let user = {};
                [user.name, user.secondName] = arr;

                Остаточные параметры
                    Если необходимо вытащить только часть параметров, а остальные запихнуть в массив, то:
                    let arr = ["1", "2", "3", "4", "5"];
                    let [a, b, ...c] = arr;
                    alert( a );//"1"
                    alert( b );//"2"
                    alert( c );//["3", "4", "5"]
            
            Объекты
                let optins {
                    title: "Menu",
                    width: 100,
                    height: 200
                };
                let {title, width, height} = optins;
                alert( title );//"Menu"
                alert( width );//100
                alert( height );//200
                //Порядок переменных не имеет значение
                //let {height, width, title} = optins; тоже будет работать
                Если необходимо присвоить произвольной переменной:
                    let {width: w, height: h, title} = optins;
                    alert( title );//"Menu"
                    alert( w );//100
                    alert( h );//200

    JSON
        JSON.stringify(value, [replacer, space])
            - value - значечние для кодирования
            - replacer - массив св-в для кодирования или функция соответствия function(key, value)
            - space - отступы

            Пропускает функции, символы и undefined

        JSON.parse(str, [revier])
            - str - строка, которую необходимо разобрать
            - revier - необязательная функция, которая будет вызываться для каждой пары (key, value)